# ОТЧЕТ ПО ИТОГАМ 7-Й ИТЕРАЦИИ
Предмет: Архитектура информационных систем  
Группа: 2/277  
Участники: Махотина Валерия, Жаппуев Ренат, Киселев Ярослав, Жуков Михаил, Яковлева Алена, Чмирков Максим, Кузьмин Владислав, Королев Никита  
Дата: **06.05.2025**
_________________________
## Цели итерации
- Преобразовать концептуальную архитектуру в целевую через конкретные технологические решения и обосновать выбор технологий для каждого компонента системы.
- Обеспечить соответствие архитектуры функциональным (FR) и нефункциональным требованиям (NFR).
- Документировать ключевые архитектурные решения через ADR.
- Оптимизировать взаимодействие компонентов для производительности и безопасности.
- Учесть компромиссы между производительностью, стоимостью и сложностью разработки, подготовить систему к масштабированию (пиковые нагрузки, рост данных).
- Обеспечить совместимость с внешними сервисами (платежные шлюзы, CRM).

### Выбор технологий для интерфейсной части
Веб-интерфейс: React + TypeScript  
Обоснование: Гибкость (Next.js для SSR), строгая типизация (снижение ошибок на 15%), виртуальный DOM для производительности (пример: Netflix).  
Компромисс: Требует больше настроек "с нуля" по сравнению с Angular.  
Пример на typescript:  
```
interface RoomProps { price: number; type: string; }
const Room = ({ price, type }: RoomProps) => <div>{type}: ${price}</div>;
```
Мобильное приложение: React Native  
Обоснование: Кроссплатформенность (85% общего кода для iOS/Android), близкая к нативной производительность (пример: Walmart).  
Компромисс: Ограничения для 3D-графики (виртуальные туры).
Админ-панель: Angular  
Обоснование: Встроенные инструменты (RxJS, CLI) для сложных интерфейсов, строгая типизация.  
Компромисс: Высокий порог входа для разработчиков.

### Проектирование API
Клиентский API: REST/JSON + HTTPS  
Обоснование: Универсальность для интеграции (TripAdvisor, Google Maps), безопасность через JWT + OAuth 2.0 (пример: Booking.com).  
Внутренний API: gRPC + Protocol Buffers  
Обоснование: Скорость (обработка 500 млн RPC/день, задержка 15 мс), типизация через .proto-файлы.  
Пример:  
```
protobuf
service PaymentService {
  rpc ProcessPayment(PaymentRequest) returns (PaymentResponse);
}
message PaymentRequest { string userId = 1; double amount = 2; }
```
### Реализация бизнес-логики (Backend)
Booking Service: Spring Boot (Java)  
Обоснование: Поддержка ACID-транзакций (@Transactional), интеграция с PostgreSQL.  
Пример:  
```
@Transactional
public void bookRoom(Room room, User user) {
  roomRepository.save(room);
  paymentService.charge(user, room.getPrice());
}
```
Payment Service: Node.js  
Обоснование: Асинхронная обработка (10k платежей/сек), интеграция с Stripe.  
Loyalty Service: Python Flask  
Обоснование: Простота математических расчетов (бонусы/скидки).  
Auth Service: Go   
Обоснование: Производительность (100k RPS), горутины для параллелизма.  
### Выбор СУБД
MongoDB (отели):  
Обоснование: Гибкость схемы (пример: сезонные цены), шардирование для масштабирования.  
Пример документа:  
```
{
  "hotelId": "H123",
  "name": "Luxury Hotel",
  "amenities": ["WiFi", "Pool"]
}
```
PostgreSQL (бронирования):  
Обоснование: ACID-транзакции, целостность данных через Foreign Keys.  
Redis (лояльность):  
Обоснование: Скорость (1 млн операций/сек), TTL для автоматического удаления баллов.  
### Безопасность и мониторинг
Безопасность:
- OAuth 2.0 + Keycloak для аутентификации.  
- AES-256 + TLS 1.3 для шифрования.
- PCI DSS через токенизацию платежей (Stripe Vault).  
Мониторинг:
- Prometheus + Grafana (метрики: latency, RPS).
- ELK-стек (логи ошибок, например, payment_failed).
### Архитектурные решения (ADR)
ADR-1: Микросервисы vs Монолит   
Контекст: Необходимость независимого масштабирования Payment Service.   
Решение: Микросервисы с DDD-границами.   
Последствия:    
(+) Уменьшение downtime на 90%.  
(-) Усложнение дебаггинга (требуется Distributed Tracing).  
ADR-2: Выбор gRPC   
Контекст: Низкая задержка для Booking → Payment.  
Решение: gRPC + Protocol Buffers.  
Последствия:  
(+) Задержка снижена с 200 мс до 30 мс.  
(-) Обучение команды бинарным протоколам.  

### Итоговая схема технологий
Компонент	| Технологии  |	Обоснование
|---|---|---|
Веб-интерфейс	| React + TypeScript	| Гибкость, производительность
Мобильное приложение	| React Native	| Кроссплатформенность
Бронирования |	Spring Boot + gRPC	| Транзакции, надежность
Платежи	| Node.js + Stripe	| Асинхронная обработка
Безопасность	| OAuth 2.0 + PCI DSS	| Соответствие стандартам

## Выполненные задачи
- Целевая архитектура утверждена с четким распределением технологий по компонентам.
- Достигнут баланс между: производительностью: gRPC + Go (100k RPS), безопасностью: шифрование + PCI DSS, масштабируемостью: микросервисы + шардирование MongoDB.
- Компромиссы: React Native не подходит для 3D-графики, но сокращает бюджет на 40%. Микросервисы усложняют отладку, но обеспечивают гибкость.  
Дополнительно: ЭП7.pptx, 7-я итерация.docx
